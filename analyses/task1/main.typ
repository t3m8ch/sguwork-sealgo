#import "../conf.typ": conf

#show: conf.with(
  meta: (
    title: "Анализ сложности сортировок, не использующих сравнение элементов",
    author: "Кудяков Артём Александрович",
    group: "251",
    city: "Саратов",
    year: 2025,
  )
)

= Сортировка подсчётом

== Код программы

```cpp
#include <iostream>
#include <vector>

void countingSort(std::vector<int>& arr, int maxNumber) {
    // в этом векторе будет хранится количество какого-либо числа в векторе arr
    // (это число соответствует индексу numbersCount), мы сразу создаём maxNumber + 1
    // элементов внутри вектора и заполняем их нулями (+1, потому что индексация с нуля)
    std::vector<int> numbersCount(maxNumber + 1, 0);

    // подсчитываем количество каждого числа в arr
    for (int num : arr) {
        numbersCount[num]++;
    }

    // мы проходим по каждому индексу из maxNumber (значение по индексу содержит
    // количество числа под индексом в arr), смотрим значение по индексу и
    // записываем индекс в arr столько раз, сколько записано в значении по индексу
    // (то есть столько, сколько раз число под индексом встречается в arr)
    int arrIndex = 0;
    for (int i = 0; i < maxNumber + 1; i++) {
        for (int j = 0; j < numbersCount[i]; j++) {
            arr[arrIndex++] = i;
        }
    }
}

int main() {
    int n;  // кол-во элементов
    std::cin >> n;

    // указываем capacity = n, тем самым сразу аллоцировав место под n элеметов
    std::vector<int> arr;
    arr.reserve(n);

    // при вводе чисел мы сразу найдём максимальное число, чтобы аллоцировать
    // вектор нужной размерности
    int maxNumber = -1;

    // заполняем массив
    for (int i = 0; i < n; i++) {
        int num;
        std::cin >> num;
        arr.push_back(num);

        if (num > maxNumber) {
            maxNumber = num;
        }
    }

    // сортируем массив
    countingSort(arr, maxNumber);

    // выводим массив на экран
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}
```

== Анализ сложности

+ *Поиск максимального элемента* \
  $O(n)$ --- во время ввода каждого числа выполняем проверку, что введённое число больше текущего максимального, если это так, то обновляем максимальное число (n --- количество чисел).
+ *Создание вспомогательного массива `numbersCount` для подсчёта* \
  $O(k)$, где $k$ --- максимальное число.
+ *Подсчёт элементов* \
  $O(n)$ --- мы проходим по массиву чисел и увеличиваем количество соответствующего элемента в вспомогательном массиве `numbersCount`.
+ *Перезапись исходного массива в отсортированном порядке* \
  Взглянем на цикл:
  ```cpp
  int arrIndex = 0;
  for (int i = 0; i < maxNumber + 1; i++) {
      for (int j = 0; j < numbersCount[i]; j++) {
          arr[arrIndex++] = i;
      }
  }
  ```
  Пусть $n_i$ = ```cpp numbersCount[i]```. Очевидно, что $n = n_0 + n_1 + ... + n_(k-1)$.

  Значит, количество проверок внешнего цикла равно $k$, а количество проверок внутреннего цикла равно $n_0 + n_1 + ... + n_(k-1) = n$.

  Итого, сложность этого цикла составляет $O(k + n)$.
+ *Общая временная сложность* --- $O(n) + O(k) + O(n) + O(n + k) = O(n + k + n + n + k) = O(3n + 2k) = O(n + k)$

#pagebreak()

= Поразрядная сортировка

== Код программы

```cpp
#include <vector>
#include <array>
#include <iostream>

void radixLSDSort(std::vector<int>& arr, int maxNumber) {
    // индекс массива векторов -- это цифра, которая содержится в разряде числа,
    // этот разряд соответствует множителю multiplier
    std::array<std::vector<int>, 10> buckets;
    int multiplier = 1;

    // цикл работает до тех пор, пока проверяемый разряд не станет старше, чем
    // максимально страший разряд чисел из arr
    while (maxNumber >= multiplier) {
        // добавляем числа из arr в соответствующий вектор из массива векторов
        for (int num : arr) {
            buckets[num / multiplier % 10].push_back(num);
        }

        // переписываем в arr отсортированную по текущему разряду
        // последовательность чисел
        int arrIndex = 0;
        for (auto& bucket : buckets) {
            for (int num : bucket) {
                arr[arrIndex++] = num;
            }

            // очищаем вектор, чтобы его можно было переиспользовать
            // на следующей итерации
            bucket.clear();
        }

        // переходим к следующему разряду
        multiplier *= 10;
    }
}

int main() {
    int n;  // кол-во элементов
    std::cin >> n;

    // указываем capacity = n, тем самым сразу аллоцировав место под n элеметов
    std::vector<int> arr;
    arr.reserve(n);

    // при вводе чисел мы сразу найдём максимальное число, чтобы аллоцировать
    // вектор нужной размерности
    int maxNumber = -1;

    // заполняем массив
    for (int i = 0; i < n; i++) {
        int num;
        std::cin >> num;
        arr.push_back(num);

        if (num > maxNumber) {
            maxNumber = num;
        }
    }

    // сортируем массив
    radixLSDSort(arr, maxNumber);

    // выводим массив на экран
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}
```

== Анализ сложности

+ *Поиск максимального элемента* \
  $O(n)$ --- во время ввода каждого числа выполняем проверку, что введённое число больше текущего максимального, если это так, то обновляем максимальное число (n --- количество чисел).
+ *Создание массива `buckets`* --- $O(1)$
+ *Цикл ```cpp while (maxNumber >= multiplier)```* \
  В конце цикла мы выполняем ```cpp multiplier *= 10```. \
  Условие выхода из цикла ```cpp maxNumber < multiplier```. \
  Значит, итераций у цикла будет $O(k)$, где $k$ --- количество разрядов в максимальном числе.
+ *Распределение элементов по корзинам* \
  Выполняется внутри цикла ```cpp while (maxNumber >= multiplier)```. На каждую итерацию этого цикла выполняется $O(n)$ операций, где $n$ --- количество элементов в массиве.
+ *Сбор элементов из корзин* \
  Также выполняется внутри ```cpp while (maxNumber >= multiplier)```. Все 10 корзин в общей сумме содержат $n$ элементов, поэтому сбор элементов из корзин выполняется за $O(n)$.
+ *Общая временная сложность* --- $O(k) * (O(n) + O(n)) = O(k n)$
