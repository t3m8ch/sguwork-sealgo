#import "../conf.typ": conf

#show: conf.with(
  meta: (
    title: "Оценка сложности префикс-функции, Z-функции и алгоритма КМП",
    author: "Кудяков Артём Александрович",
    group: "251",
    city: "Саратов",
    year: 2025,
  )
)

= Префикс-функция

== Код программы

```cpp
#pragma once

#include <string>
#include <vector>

std::vector<int> prefixFunc(const std::string &s) {
  std::vector<int> p(s.size(), 0);

  for (size_t i = 1; i < s.size(); i++) {
    size_t cur = p[i - 1];

    while (s[i] != s[cur] && cur > 0) {
      cur = p[cur - 1];
    }

    if (s[i] == s[cur]) {
      p[i] = cur + 1;
    }
  }

  return p;
}
```

== Анализ сложности

+ Инициализация вектора происходит за $O(n)$.
+ Переменная `cur` может
  - Увеличиться на 1 за одну итерацию внешнего цикла
  - Уменьшиться во внутреннем цикле `while`
+ $pi [0] = 0$
+ Из 2 и 3 $=> pi [i] <= pi [i - 1] + 1 => sum_(i=0)^(n-1) pi [i] <= n$
+ Это значит, что если мы сложим количество итераций внутреннего цикла,
  произошедших во всех итерациях внешнего цикла, то получим $O(n)$.
+ Внешний цикл выполняется за $O(n)$.
+ Из 5 и 6 $=>$ *общая сложность алгоритма $= O(n) + O(n) = O(n)$*

#pagebreak()

= Z-функция

== Код программы

```cpp
#include <string>
#include <vector>

std::vector<int> zFunc(const std::string &s) {
  std::vector<int> zf(s.size(), 0);
  int left = 0, right = 0;

  for (int i = 1; i < s.size(); i++) {
    zf[i] = std::max(0, std::min(right - i, zf[i - left]));
    while (i + zf[i] < s.size() && s[zf[i]] == s[i + zf[i]])
      zf[i]++;

    if (i + zf[i] > right) {
      left = i;
      right = i + zf[i];
    }
  }

  return zf;
}
```

== Анализ сложности

+ Для начала докажем, что в цикле `while` мы сравниваем только символы $>=$ right
  + Перед циклом $"zf"[i] >= max(0, "right" - i)$
  + $=> i + "zf"[i] >= i + max(0, "right" - 1) = max(i, "right")$
  + $i >= 1 => i + "zf"[i] >= "right"$
+ После каждой итерации, если ```cpp i + zf[i] > right```, то ```cpp right = i + zf[i]```
+ Это означает, что мы только что сравнили символ на позиции `right` и далее мы будем
  сравнивать только те символы, которые идут строго после него.
+ А из этого следует, что общее количество сравнений внутри цикла `while` равно тому,
  сколько раз `right` может увеличиться.
+ Докажем, что `right` может увеличиваться максимум до $n$:
  + `right` начинается с 0
  + `right` может увеличиваться максимум до $n$, так как
    + ```cpp right = i + zf[i]```
    + `i` может увеличиваться от $1$ до $n - 1$ (по циклу `for`)
    + `zf[i]` может быть от $0$ до $n - i$ (из определения Z-функции следует, что
      $n - i$ --- максимальная длина совпадения)
    + Крайний случай возникает при $i = 1$ и $"zf"[1] = n - 1$, тогда $"right" = 1 + (n - 1) = n$
+ Итого, мы имеем, что все сравнения в сумме, если складывать итерации и внутреннего цикла,
  и внешнего, составляют $O(n)$.
+ Сложность внешнего цикла `for` равна $O(n)$.
+ Инициализация вектора, который будет хранить Z-функцию --- $O(n)$.
+ *Итоговая сложность алгоритма = $O(n) + O(n) + O(n) = O(n)$*.

= КМП

== Код программы

```cpp
#pragma once

#include "prefix-func.hpp"
#include <optional>

std::optional<size_t> kmpSearch(const std::string &text,
                                const std::string &pattern) {
  size_t j = 0;
  auto pi = prefixFunc(pattern);

  for (size_t i = 0; i < text.size(); i++) {
    while (j > 0 && text[i] != pattern[j]) {
      j = pi[j - 1];
    }

    if (text[i] == pattern[j]) {
      j++;
    }

    if (j >= pattern.size()) {
      return std::optional<size_t>(i - j + 1);
    }
  }

  return std::nullopt;
}
```

== Анализ сложности

+ Пусть $n$ --- длина текста, $k$ --- длина паттерна.
+ Вычисление префикс-функции происходит за $O(k)$.
+ Докажем, что общее количество увеличений $j <= n$:
  + Общее количество увеличений $j <=$ общего количества увеличений $i$ (это видно из кода).
  + Общее количество увеличений $i <= n$ (это видно из цикла `for`).
  + Из 1 и 2 $=>$ общее количество увеличений $j <= n$
+ Из этого следует, что и общее количество уменьшений $j <= n$.
+ А значит амортизированная сложность цикла `while` $= O(n)$.
+ Внешний цикл `for` также выполняется $O(n)$ раз.
+ *Итоговая сложность алгоритма $O(k) + O(n) + O(n) = O(n + k)$*.
